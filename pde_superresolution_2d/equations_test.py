# Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import numpy as np
import tensorflow as tf

from absl.testing import absltest

from pde_superresolution_2d import equations
from pde_superresolution_2d import grids
from pde_superresolution_2d import metadata_pb2
from pde_superresolution_2d import velocity_fields


# TODO(dkochkov) update initialization and bring back boundary test.


def _test_initial_conditions_shape(
    equation: equations.Equation,
    init_method: equations.InitialConditionMethod,
    grid: grids.Grid,
    batch_size: int,
    **kwargs):
  """Tests the shape of initial conditions generated by equation."""
  init_state = equation.initial_state(init_method, grid, batch_size, **kwargs)
  for key in equation.STATE_KEYS:
    initial_values = init_state[key]
    np.testing.assert_equal(np.shape(initial_values), (batch_size,) +
                            grid.get_shape())


def _test_tensor_state_conversion(equation: equations.Equation,
                                  grid: grids.Grid):
  """Test that tensor->state and state->tensor commute."""
  state = equation.initial_state(
      equations.InitialConditionMethod.GAUSSIAN, grid)
  tensor_form = equation.to_tensor(state)
  back_to_state = equation.to_state(tensor_form)
  if set(state.keys()) != set(back_to_state.keys()):
    raise AssertionError('state did not recover all the keys from the tensor.')
  for key in state.keys():
    np.testing.assert_allclose(state[key], back_to_state[key])


def _test_tensor_state_conversion_tf(equation: equations.Equation,
                                     grid: grids.Grid):
  """Test that tensor->state and state->tensor commute."""
  state = equation.initial_state(
      equations.InitialConditionMethod.GAUSSIAN, grid)
  with tf.Graph().as_default():
    tensor_form = equation.to_tensor(state)
    back_to_state_tensor = equation.to_state(tensor_form)
    with tf.Session() as sess:
      back_to_state = sess.run(back_to_state_tensor)
  if set(state.keys()) != set(back_to_state.keys()):
    raise AssertionError('state did not recover all the keys from the tensor.')
  for key in state.keys():
    np.testing.assert_allclose(state[key], back_to_state[key])


class EquationsTest(absltest.TestCase):
  """Test Equation interface and instantiation calls."""

  def test_equation_map(self):
    finite_diff_key = ('advection_diffusion', metadata_pb2.Equation.FINITE_DIFF)
    finite_diff_advection = equations.EQUATION_TYPES[finite_diff_key]

    finite_vol_key = (
        'advection_diffusion', metadata_pb2.Equation.FINITE_VOLUME)
    finite_volume_advection = equations.EQUATION_TYPES[finite_vol_key]

    upwind_key = ('advection_diffusion', metadata_pb2.Equation.UPWIND)
    upwind_advection = equations.EQUATION_TYPES[upwind_key]

    self.assertEqual(
        finite_diff_advection, equations.FiniteDifferenceAdvectionDiffusion)
    self.assertEqual(
        finite_volume_advection, equations.FiniteVolumeAdvectionDiffusion)
    self.assertEqual(
        upwind_advection, equations.FiniteVolumeUpwindAdvectionDiffusion)


class FiniteDifferenceAdvectionTest(absltest.TestCase):
  """Test Equation classes defined in equations.py."""

  def setUp(self):
    self.grid = grids.Grid(200, 200, 2 * np.pi / 200)
    velocity_field = velocity_fields.ConstantVelocityField.from_seed(5, 4, 10)
    self.equation = equations.FiniteDifferenceAdvectionDiffusion(
        velocity_field=velocity_field, diffusion_const=0.1)

  def test_tensor_state_conversion(self):
    _test_tensor_state_conversion(self.equation, self.grid)

  def test_initial_conditions(self):
    gaussian_init = equations.InitialConditionMethod.GAUSSIAN
    kwargs = {'x_position': 1., 'y_position': 1, 'gaussian_width': 0.2}
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=1, **kwargs)
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=3, **kwargs)

  def test_proto_conversion(self):
    equation_proto = self.equation.to_proto()
    proto = equation_proto.advection_diffusion
    self.assertEqual(proto.diffusion_const, self.equation.diffusion_const)
    equation_from_proto = equations.equation_from_proto(equation_proto)
    np.testing.assert_allclose(
        equation_from_proto.velocity_field.get_velocity_x(0, self.grid),
        self.equation.velocity_field.get_velocity_x(0, self.grid))
    np.testing.assert_allclose(
        equation_from_proto.velocity_field.get_velocity_y(0, self.grid),
        self.equation.velocity_field.get_velocity_y(0, self.grid))


class FiniteVolumeAdvectionTest(absltest.TestCase):
  """Test Equation classes defined in equations.py."""

  def setUp(self):
    self.grid = grids.Grid(200, 200, 2 * np.pi / 200)
    velocity_field = velocity_fields.ConstantVelocityField.from_seed(5, 4, 10)
    self.equation = equations.FiniteVolumeAdvectionDiffusion(
        velocity_field=velocity_field, diffusion_const=0.1)

  def test_tensor_state_conversion(self):
    _test_tensor_state_conversion(self.equation, self.grid)

  def test_initial_conditions(self):
    gaussian_init = equations.InitialConditionMethod.GAUSSIAN
    kwargs = {'x_position': 1., 'y_position': 1, 'gaussian_width': 0.2}
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=1, **kwargs)
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=3, **kwargs)

  def test_proto_conversion(self):
    equation_proto = self.equation.to_proto()
    proto = equation_proto.advection_diffusion
    self.assertEqual(proto.diffusion_const, self.equation.diffusion_const)
    equation_from_proto = equations.equation_from_proto(equation_proto)
    np.testing.assert_allclose(
        equation_from_proto.velocity_field.get_velocity_x(0, self.grid),
        self.equation.velocity_field.get_velocity_x(0, self.grid))
    np.testing.assert_allclose(
        equation_from_proto.velocity_field.get_velocity_y(0, self.grid),
        self.equation.velocity_field.get_velocity_y(0, self.grid))


class UpwindAdvectionTest(absltest.TestCase):
  """Test Equation classes defined in equations.py."""

  def setUp(self):
    self.grid = grids.Grid(200, 200, 2 * np.pi / 200)
    velocity_field = velocity_fields.ConstantVelocityField.from_seed(5, 4, 10)
    self.equation = equations.FiniteVolumeUpwindAdvectionDiffusion(
        velocity_field=velocity_field, diffusion_const=0.1)

  def test_tensor_state_conversion(self):
    _test_tensor_state_conversion(self.equation, self.grid)

  def test_initial_conditions(self):
    gaussian_init = equations.InitialConditionMethod.GAUSSIAN
    kwargs = {'x_position': 1., 'y_position': 1, 'gaussian_width': 0.2}
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=1, **kwargs)
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=3, **kwargs)

  def test_proto_conversion(self):
    equation_proto = self.equation.to_proto()
    proto = equation_proto.advection_diffusion
    self.assertEqual(proto.diffusion_const, self.equation.diffusion_const)
    equation_from_proto = equations.equation_from_proto(equation_proto)
    np.testing.assert_allclose(
        equation_from_proto.velocity_field.get_velocity_x(0, self.grid),
        self.equation.velocity_field.get_velocity_x(0, self.grid))
    np.testing.assert_allclose(
        equation_from_proto.velocity_field.get_velocity_y(0, self.grid),
        self.equation.velocity_field.get_velocity_y(0, self.grid))


class InStateVelocityFiniteVolumeAdvectionTest(absltest.TestCase):
  """Test Equation classes defined in equations.py."""

  def setUp(self):
    self.grid = grids.Grid(200, 200, 2 * np.pi / 200)
    self.equation = equations.InStateVelocityFiniteVolumeAdvectionDiffusion(
        velocity_field=None, diffusion_const=0.1)

  def test_tensor_state_conversion(self):
    _test_tensor_state_conversion_tf(self.equation, self.grid)

  def test_initial_conditions(self):
    gaussian_init = equations.InitialConditionMethod.GAUSSIAN
    kwargs = {'x_position': 1., 'y_position': 1, 'gaussian_width': 0.2}
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=1, **kwargs)
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=3, **kwargs)

  def test_proto_conversion(self):
    equation_proto = self.equation.to_proto()
    proto = equation_proto.in_state_velocity_advection_diffusion
    self.assertEqual(proto.diffusion_const, self.equation.diffusion_const)
    equation_from_proto = equations.equation_from_proto(equation_proto)
    self.assertIsInstance(
        equation_from_proto,
        equations.InStateVelocityFiniteVolumeAdvectionDiffusion)


class InStateVelocityUpwindAdvectionTest(absltest.TestCase):
  """Test Equation classes defined in equations.py."""

  def setUp(self):
    self.grid = grids.Grid(200, 200, 2 * np.pi / 200)
    self.equation = equations.InStateVelocityUpwindAdvectionDiffusion(
        velocity_field=None, diffusion_const=0.1)

  def test_tensor_state_conversion(self):
    _test_tensor_state_conversion_tf(self.equation, self.grid)

  def test_initial_conditions(self):
    gaussian_init = equations.InitialConditionMethod.GAUSSIAN
    kwargs = {'x_position': 1., 'y_position': 1, 'gaussian_width': 0.2}
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=1, **kwargs)
    _test_initial_conditions_shape(self.equation, gaussian_init,
                                   self.grid, batch_size=3, **kwargs)

  def test_proto_conversion(self):
    equation_proto = self.equation.to_proto()
    proto = equation_proto.in_state_velocity_advection_diffusion
    self.assertEqual(proto.diffusion_const, self.equation.diffusion_const)
    equation_from_proto = equations.equation_from_proto(equation_proto)
    self.assertIsInstance(
        equation_from_proto,
        equations.InStateVelocityUpwindAdvectionDiffusion)


if __name__ == '__main__':
  absltest.main()
