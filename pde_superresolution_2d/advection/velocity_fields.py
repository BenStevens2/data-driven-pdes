# Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Deterministic velocity fields for advection-diffusion equation."""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import enum
import numpy as np
from pde_superresolution_2d import metadata_pb2
from pde_superresolution_2d.core import grids
import tensorflow as tf
from typing import Any, Tuple, TypeVar


class VelocityComponent(enum.Enum):
  """Enum representing valid velocity field components."""
  X = 1
  Y = 2


class VelocityField(object):
  """Base class for implementations of velocity fields.

  Defines methods get_velocity_x and get_velocity_y used by equation classes.
  """

  def get_velocity_x(
      self,
      t: float,
      grid: grids.Grid,
      shift: Tuple[int, int] = (0, 0),
      cell_average: bool = False,
  ) -> tf.Tensor:
    """Returns a tensor holding x component of the velocity field.

    Args:
      t: Time at which to evaluate the velocity fields.
      grid: Grid object on which the field is evaluated.
      shift: Number of half-step shifts on the grid along x and y axes.
      cell_average: If true, return the cell-average around each point rather
        than point values directly.

    Returns:
      x component of the velocity field as tensor with
      shape=[grid.size_x, grid.size_y] and dtype=float64.
    """
    raise NotImplementedError

  def get_velocity_y(
      self,
      t: float,
      grid: grids.Grid,
      shift: Tuple[int, int] = (0, 0),
      cell_average: bool = False,
  ) -> tf.Tensor:
    """Returns a tensor holding y component of the velocity field.

    Args:
      t: Time at which to evaluate the velocity fields.
      grid: Grid object on which the field is evaluated.
      shift: Number of half-step shifts on the grid along x and y axes.
      cell_average: If true, return the cell-average around each point rather
        than point values directly.

    Returns:
      y component of the velocity field as tensor with
      shape=[grid.size_x, grid.size_y] and dtype=float64.
    """
    raise NotImplementedError

  def to_proto(self) -> metadata_pb2.VelocityField:
    """Creates a protocol buffer holding parameters of the velocity field."""
    raise NotImplementedError

  def from_proto(self, proto: Any):
    """Reads a protocol buffer to reconstruct the values of the velocity field.

    Args:
      proto: Protocol buffer holding the velocity field data.
    """
    raise NotImplementedError


T = TypeVar('T')


class ConstantVelocityField(VelocityField):
  """Implementation of a random, divergence-less constant velocity field.

  Attributes:
    amplitudes: ndarray of float amplitudes of sin() terms.
    x_wavenumbers: ndarray of integer spatial x-frequencies of sin() terms.
    y_wavenumbers: ndarray of integer spatial y-frequencies of sin() terms.
    phase_shifts: ndarray of float phase shifts of sin() terms.
  """

  def __init__(self,
               x_wavenumbers: np.ndarray,
               y_wavenumbers: np.ndarray,
               amplitudes: np.ndarray,
               phase_shifts: np.ndarray):
    """Constructor."""
    if not (x_wavenumbers.shape == y_wavenumbers.shape ==
            amplitudes.shape == phase_shifts.shape):
      raise ValueError('mismatched shapes')
    self.x_wavenumbers = x_wavenumbers
    self.y_wavenumbers = y_wavenumbers
    self.amplitudes = amplitudes
    self.phase_shifts = phase_shifts

  @property
  def num_terms(self) -> int:
    """Integer number of sin() terms used to initialize random field."""
    return self.amplitudes.size

  @property
  def max_periods(self):
    """Integer limit on how many periods fit in 2 * pi domain."""
    return max(abs(self.x_wavenumbers).max(), abs(self.y_wavenumbers).max())

  def evaluate(
      self,
      component: VelocityComponent,
      grid: grids.Grid,
      shift: Tuple[int, int] = (0, 0),
  ) -> np.ndarray:
    """Evaluate this velocity field on the given grid.

    Generates numerical values of the field on the mesh generated by the grid.
    Shift argument can be used to evaluate the velocity field on the boundary.

    Args:
      component: Component of the velocity to be evaluated.
      grid: Grid object defining the mesh on which velocity is evaluated.
      shift: Number of half-step shifts on the grid along x and y axes.

    Returns:
      Float64 array with shape [X, Y] giving requested velocity field component.
    """

    x, y = grid.get_mesh(shift)

    # We use the axis order [x, y, term]
    x = x[..., np.newaxis]
    y = y[..., np.newaxis]

    k_x = 2 * np.pi * self.x_wavenumbers / grid.length_x
    k_y = 2 * np.pi * self.y_wavenumbers / grid.length_y

    phase = k_x * x + k_y * y + self.phase_shifts
    calculate_vx = component is VelocityComponent.X
    scale = self.y_wavenumbers if calculate_vx else -self.x_wavenumbers
    return (scale * self.amplitudes * np.sin(phase)).sum(axis=-1)

  def cell_average(
      self,
      component: VelocityComponent,
      grid: grids.Grid,
      shift: Tuple[int, int] = (0, 0),
  ) -> np.ndarray:
    """Calculate the cell-averaged velocity field centerd on the given grid.

    Like evaluate(), but the resulting field is (exactly) averaged over the unit
    cell centerd on each point.

    Args:
      component: Component of the velocity to be evaluated.
      grid: Grid object defining the mesh on which velocity is evaluated.
      shift: Number of half-step shifts on the grid along x and y axes.

    Returns:
      Float64 array with shape [X, Y] giving requested velocity field component.
    """
    # Shift a half-unit cell down and left; we'll roll to evaluate on the
    # other cell boundaries.
    # boundary_shift = (shift[0] - 1, shift[1] - 1)
    x, y = grid.get_mesh(shift)

    # We use the axis order [x, y, term]
    x = x[..., np.newaxis]
    y = y[..., np.newaxis]

    k_x = 2 * np.pi * self.x_wavenumbers / grid.length_x
    k_y = 2 * np.pi * self.y_wavenumbers / grid.length_y

    phase = k_x * x + k_y * y + self.phase_shifts
    calculate_vx = component is VelocityComponent.X
    scale = self.y_wavenumbers if calculate_vx else -self.x_wavenumbers

    # This 2D definite integral is straightforward to calculate, but we need to
    # consider four different cases, depending upon if either the x or y
    # wavenumbers are zero.

    # Everything follows out from repeated application of a few basic integrals:
    #   integral(sin(k x + c), dx) = -cos(k x + c) / k
    #   integral(cos(k x + c), dx) = sin(k x + c) / k
    # But see these Wolfram Alpha results if you don't want to bother with the
    # book-keeping yourself:
    # https://www.wolframalpha.com/input/?i=integral+of+sin(k+x+%2B+c)+over+x+from+x0+to+x1+and+y+from+y0+to+y1
    # https://www.wolframalpha.com/input/?i=integral+of+sin(k+x+%2B+h+y+%2B+c)+over+x+from+x0+to+x1+and+y+from+y0+to+y1

    # Note that if either wave-number is 0, the term in the field is a constant
    # in that direction, so the shift we used on the grid doesn't matter.

    result = np.zeros(grid.shape)

    neither_zero = (self.x_wavenumbers != 0) & (self.y_wavenumbers != 0)
    if neither_zero.any():
      # double integral over x and y
      indefinite_integral = (scale[neither_zero]
                             / (k_x[neither_zero] * k_y[neither_zero])
                             * self.amplitudes[neither_zero]
                             * -np.sin(phase[..., neither_zero])).sum(axis=-1)
      result += grid.step ** -2 * (
          + np.roll(indefinite_integral, (-1, -1), axis=(0, 1))
          - np.roll(indefinite_integral, -1, axis=0)
          - np.roll(indefinite_integral, -1, axis=1)
          + indefinite_integral
      )

    wxonly_zero = (self.x_wavenumbers == 0) & (self.y_wavenumbers != 0)
    if wxonly_zero.any():
      # integrate over y
      indefinite_integral = (scale[wxonly_zero] / k_y[wxonly_zero] *
                             self.amplitudes[wxonly_zero] *
                             -np.cos(phase[..., wxonly_zero])).sum(axis=-1)
      result += grid.step ** -1 * (
          + np.roll(indefinite_integral, -1, axis=1)
          - indefinite_integral
      )

    wyonly_zero = (self.x_wavenumbers != 0) & (self.y_wavenumbers == 0)
    if wyonly_zero.any():
      # integrate over x
      indefinite_integral = (scale[wyonly_zero] / k_x[wyonly_zero] *
                             self.amplitudes[wyonly_zero] *
                             -np.cos(phase[..., wyonly_zero])).sum(axis=-1)
      result += grid.step ** -1 * (
          + np.roll(indefinite_integral, -1, axis=0)
          - indefinite_integral
      )

    both_zero = (self.x_wavenumbers == 0) & (self.y_wavenumbers == 0)
    if both_zero.any():
      # no integrals
      result += (scale[both_zero] *
                 self.amplitudes[both_zero] *
                 np.sin(phase[..., both_zero])).sum(axis=-1)

    return result

  def get_velocity_x(
      self,
      t: float,
      grid: grids.Grid,
      shift: Tuple[int, int] = (0, 0),
      cell_average: bool = False,
  ) -> tf.Tensor:
    """See base class."""
    del t  # constant velocity field is time independent
    method = self.cell_average if cell_average else self.evaluate
    velocity_x = method(VelocityComponent.X, grid, shift)
    return velocity_x

  def get_velocity_y(
      self,
      t: float,
      grid: grids.Grid,
      shift: Tuple[int, int] = (0, 0),
      cell_average: bool = False,
  ) -> tf.Tensor:
    """See base class."""
    del t  # constant velocity field is time independent
    method = self.cell_average if cell_average else self.evaluate
    velocity_y = method(VelocityComponent.Y, grid, shift)
    return velocity_y

  def to_proto(self) -> metadata_pb2.VelocityField:
    """Creates a protocol buffer holding parameters of the velocity field.

    Returns:
      Protocol buffer holding parameters of the velocity field.
    """
    proto = metadata_pb2.VelocityField(
        constant_v_field=dict(
            amplitudes=self.amplitudes.tolist(),
            x_wavenumbers=self.x_wavenumbers.tolist(),
            y_wavenumbers=self.y_wavenumbers.tolist(),
            phase_shifts=self.phase_shifts.tolist()
        )
    )
    return proto

  @classmethod
  def from_proto(
      cls,
      proto: metadata_pb2.ConstantVelocityField
  ) -> VelocityField:
    """Creates an instance of a ConstantVelocityField from a protocol buffer.

    Args:
      proto: Protocol buffer holding constant velocity field data.

    Returns:
      ConstantVelocityField object initialized from the protocol buffer.
    """
    velocity_field = cls(
        np.asarray(proto.x_wavenumbers),
        np.asarray(proto.y_wavenumbers),
        np.asarray(proto.amplitudes),
        np.asarray(proto.phase_shifts),
    )
    return velocity_field

  @classmethod
  def from_seed(
      cls,
      max_periods: int = 4,
      power_law: float = -3,
      seed: int = None,
      normalize: bool = True,
  ) -> VelocityField:
    """Creates an instance of a ConstantVelocityField from a random seed.

    Uses a power-law distribution with a hard cutoff, namely with amplitudes
    scaled by (k+1)**n where k=(k_x**2+k_y**2)**0.5 and n is some (negative)
    constant.

    Args:
      max_periods: maximum period to use for the signal.
      power_law: power law for decay.
      seed: Seed for random number generator.
      normalize: If True, normalize the field to have a maximum velocity of
        approximately one.

    Returns:
      ConstantVelocityField object.
    """
    rnd_gen = np.random.RandomState(seed=seed)
    ks = np.arange(-max_periods, max_periods + 1)
    k_x, k_y = [k.ravel() for k in np.meshgrid(ks, ks, indexing='ij')]
    scale = ((k_x ** 2 + k_y ** 2) ** 0.5 + 1) ** float(power_law)
    amplitudes = scale * rnd_gen.random_sample(size=scale.shape)
    phase_shifts = rnd_gen.random_sample(size=scale.shape) * np.pi * 2.
    vfield = cls(k_x, k_y, amplitudes, phase_shifts)
    if normalize:
      vfield = vfield.normalize()
    return vfield

  def normalize(self: T, test_grid_size: int = 256) -> T:
    """Return a new field with maximum velocity scaled to approximately one."""
    length = 2 * np.pi
    step = length / test_grid_size
    test_grid = grids.Grid(test_grid_size, test_grid_size, step)

    v_x = self.evaluate(VelocityComponent.X, test_grid)
    v_y = self.evaluate(VelocityComponent.Y, test_grid)
    v_max = np.sqrt(v_x ** 2 + v_y ** 2).max()
    amplitudes = self.amplitudes / v_max

    return type(self)(self.x_wavenumbers, self.y_wavenumbers,
                      amplitudes, self.phase_shifts)


def velocity_field_from_proto(
    proto: metadata_pb2.VelocityField) -> VelocityField:
  """Constructs a VelocityField object from a protocol buffer.

  Args:
    proto: VelocityField message encoding the instance of a VelocityField.

  Returns:
    VelocityField object.

  Raises:
    ValueError: Provided protocol buffer was not recognized, check proto names.
  """
  if proto.WhichOneof('v_field') == 'constant_v_field':
    pb = getattr(proto, proto.WhichOneof('v_field'))
    return ConstantVelocityField.from_proto(pb)
  raise ValueError('Velocity field protocol buffer is not recognized')


